{"version":3,"mappings":"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","names":["browserAPI","CometStorageManager","error","defaultsModule","__vitePreload","obj","prefix","key","value","fullKey","keys","fallback","namespace","defaultValue","result","CometStorageError","data","results","val","storageArea","usage","syncUsed","localUsed","callback","listener","changes","items","path","storageData","lastKey","target","operation","dataSize","itemSize","message","originalError","storage","CometMessagingManager","options","messageWithId","timeout","retries","CometMessagingError","tabId","targetTabId","tabs","responses","tab","response","sender","sendResponse","type","activeTab","url","resolve","reject","timeoutId","maxRetries","lastError","attempt","delay","ms","attempts","messaging"],"ignoreList":[],"sources":["../src/platform/storage.js","../src/platform/messaging.js"],"sourcesContent":["/**\n * Comet Extension Storage Utility (Cross-Browser)\n * Enhanced storage with auto-loading defaults from defaults.json\n * Works with Chrome, Firefox, Edge, Opera, Brave, and other WebExtension browsers\n * @module @voilajsx/comet\n * @file src/platform/storage.js\n */\n\n// Cross-browser API detection\nconst browserAPI = (() => {\n  if (typeof browser !== 'undefined') {\n    return browser; // Firefox, newer browsers\n  } else if (typeof chrome !== 'undefined') {\n    return chrome; // Chrome, Edge, Opera, Brave\n  } else {\n    throw new Error('No browser extension API available');\n  }\n})();\n\n/**\n * Enhanced Comet Storage Manager\n * Auto-loads defaults and provides unified API for all data access\n */\nclass CometStorageManager {\n  constructor() {\n    this.api = browserAPI;\n    this.syncQuota = this.api.storage.sync.QUOTA_BYTES || 102400; // 100KB\n    this.localQuota = this.api.storage.local.QUOTA_BYTES || 10485760; // 10MB\n    this.syncItemQuota = this.api.storage.sync.QUOTA_BYTES_PER_ITEM || 8192; // 8KB per item\n\n    // Defaults management\n    this.defaults = {};\n    this.defaultsLoaded = false;\n    this.isInitialized = false;\n\n    this.initialize();\n  }\n\n  /**\n   * Initialize storage with auto-loading defaults\n   */\n  async initialize() {\n    if (this.isInitialized) return;\n\n    try {\n      await this.loadDefaults();\n      await this.initializeDefaults();\n      this.isInitialized = true;\n      console.log('[Comet Storage] Initialized with defaults');\n    } catch (error) {\n      console.warn(\n        '[Comet Storage] Initialization failed, continuing without defaults:',\n        error\n      );\n      this.defaults = {};\n      this.defaultsLoaded = true;\n      this.isInitialized = true;\n    }\n  }\n\n  /**\n   * Load defaults from defaults.json\n   */\n  async loadDefaults() {\n    if (this.defaultsLoaded) return;\n\n    try {\n      // Try to import defaults.json\n      const defaultsModule = await import('../defaults.json');\n      this.defaults = defaultsModule.default || {};\n      this.defaultsLoaded = true;\n      console.log('[Comet Storage] Loaded defaults from defaults.json');\n    } catch (error) {\n      console.log(\n        '[Comet Storage] No defaults.json found, using empty defaults'\n      );\n      this.defaults = {};\n      this.defaultsLoaded = true;\n    }\n  }\n\n  /**\n   * Initialize storage with defaults on first run\n   */\n  async initializeDefaults() {\n    try {\n      // Check if we've already initialized defaults\n      const isInitialized = await this.api.storage.local.get(\n        '_defaultsInitialized'\n      );\n\n      if (isInitialized._defaultsInitialized) {\n        return; // Already initialized\n      }\n\n      // Load defaults into storage\n      if (Object.keys(this.defaults).length > 0) {\n        await this.setDefaults(this.defaults);\n        console.log('[Comet Storage] Initialized storage with defaults');\n      }\n\n      // Mark as initialized\n      await this.api.storage.local.set({ _defaultsInitialized: true });\n    } catch (error) {\n      console.warn('[Comet Storage] Failed to initialize defaults:', error);\n    }\n  }\n\n  /**\n   * Recursively set default values\n   */\n  async setDefaults(obj, prefix = '') {\n    for (const [key, value] of Object.entries(obj)) {\n      const fullKey = prefix ? `${prefix}.${key}` : key;\n\n      if (value && typeof value === 'object' && !Array.isArray(value)) {\n        // Recursive for nested objects\n        await this.setDefaults(value, fullKey);\n      } else {\n        // Check if key already exists\n        const existingValue = await this.getRaw(fullKey);\n        if (existingValue === undefined) {\n          // Only set if not already exists\n          await this.setRaw(fullKey, value);\n        }\n      }\n    }\n  }\n\n  /**\n   * Get data from browser storage with auto-fallback to defaults\n   * @param {string|array|object|null} keys - Keys to retrieve\n   * @param {any} fallback - Fallback value if not found\n   * @param {string} [namespace='auto'] - Storage namespace (sync/local/auto)\n   * @returns {Promise<any>} Retrieved data\n   */\n  async get(keys = null, fallback = undefined, namespace = 'auto') {\n    try {\n      await this.initialize();\n\n      // Handle single key string\n      if (typeof keys === 'string') {\n        const value = await this.getRaw(keys, namespace);\n\n        if (value !== undefined) {\n          return value;\n        }\n\n        // Try to get from defaults\n        const defaultValue = this.getDefaultByPath(keys);\n        if (defaultValue !== undefined) {\n          return defaultValue;\n        }\n\n        return fallback;\n      }\n\n      // Handle array of keys\n      if (Array.isArray(keys)) {\n        const result = {};\n        for (const key of keys) {\n          result[key] = await this.get(key, undefined, namespace);\n        }\n        return result;\n      }\n\n      // Handle null (get all)\n      if (keys === null) {\n        const storageArea = this.getStorageArea(namespace, 'read');\n        const result = await storageArea.get(null);\n\n        // Merge with defaults\n        return this.mergeWithDefaults(result);\n      }\n\n      // Handle object (get multiple specific keys)\n      const result = {};\n      for (const key of Object.keys(keys)) {\n        result[key] = await this.get(key, keys[key], namespace);\n      }\n      return result;\n    } catch (error) {\n      console.error('[Comet Storage] Get operation failed:', error);\n      throw new CometStorageError('Failed to read from storage', error);\n    }\n  }\n\n  /**\n   * Set data to browser storage\n   * @param {object|string} data - Data to store (object) or key (string)\n   * @param {any} [value] - Value if first param is key string\n   * @param {string} [namespace='auto'] - Storage namespace (sync/local/auto)\n   * @returns {Promise<boolean>} Success status\n   */\n  async set(data, value = undefined, namespace = 'auto') {\n    try {\n      await this.initialize();\n\n      // Handle set(key, value) syntax\n      if (typeof data === 'string') {\n        return await this.setRaw(data, value, namespace);\n      }\n\n      // Handle object syntax\n      const results = [];\n      for (const [key, val] of Object.entries(data)) {\n        results.push(await this.setRaw(key, val, namespace));\n      }\n\n      return results.every((result) => result === true);\n    } catch (error) {\n      console.error('[Comet Storage] Set operation failed:', error);\n      throw new CometStorageError('Failed to write to storage', error);\n    }\n  }\n\n  /**\n   * Remove data from browser storage\n   * @param {string|array} keys - Keys to remove\n   * @param {string} [namespace='auto'] - Storage namespace (sync/local/auto)\n   * @returns {Promise<boolean>} Success status\n   */\n  async remove(keys, namespace = 'auto') {\n    try {\n      const storageArea = this.getStorageArea(namespace, 'write');\n\n      if (typeof keys === 'string') {\n        await storageArea.remove(keys);\n      } else {\n        await storageArea.remove(keys);\n      }\n\n      return true;\n    } catch (error) {\n      console.error('[Comet Storage] Remove operation failed:', error);\n      throw new CometStorageError('Failed to remove from storage', error);\n    }\n  }\n\n  /**\n   * Clear all data from browser storage\n   * @param {string} [namespace='both'] - Storage namespace (sync/local/both)\n   * @returns {Promise<boolean>} Success status\n   */\n  async clear(namespace = 'both') {\n    try {\n      if (namespace === 'both') {\n        await Promise.all([\n          this.api.storage.sync.clear(),\n          this.api.storage.local.clear(),\n        ]);\n      } else {\n        const storageArea = this.getStorageArea(namespace, 'write');\n        await storageArea.clear();\n      }\n      return true;\n    } catch (error) {\n      console.error('[Comet Storage] Clear operation failed:', error);\n      throw new CometStorageError('Failed to clear storage', error);\n    }\n  }\n\n  /**\n   * Check if data exists in storage (including defaults)\n   * @param {string} key - Key to check\n   * @param {string} [namespace='auto'] - Storage namespace\n   * @returns {Promise<boolean>} True if key exists\n   */\n  async has(key, namespace = 'auto') {\n    try {\n      const value = await this.get(key, undefined, namespace);\n      return value !== undefined;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get storage usage information\n   * @param {string} [namespace='both'] - Storage namespace (sync/local/both)\n   * @returns {Promise<object>} Usage information\n   */\n  async getUsage(namespace = 'both') {\n    try {\n      const usage = {};\n\n      if (namespace === 'both' || namespace === 'sync') {\n        const syncUsed = await this.api.storage.sync.getBytesInUse();\n        usage.sync = {\n          used: syncUsed,\n          total: this.syncQuota,\n          percentage: Math.round((syncUsed / this.syncQuota) * 100),\n          available: this.syncQuota - syncUsed,\n        };\n      }\n\n      if (namespace === 'both' || namespace === 'local') {\n        const localUsed = await this.api.storage.local.getBytesInUse();\n        usage.local = {\n          used: localUsed,\n          total: this.localQuota,\n          percentage: Math.round((localUsed / this.localQuota) * 100),\n          available: this.localQuota - localUsed,\n        };\n      }\n\n      return usage;\n    } catch (error) {\n      console.error('[Comet Storage] Usage check failed:', error);\n      return { sync: { used: 0, total: 0, percentage: 0, available: 0 } };\n    }\n  }\n\n  /**\n   * Listen to storage changes\n   * @param {function} callback - Callback function (changes, namespace) => void\n   * @returns {function} Unsubscribe function\n   */\n  onChange(callback) {\n    const listener = (changes, namespace) => {\n      callback(changes, namespace);\n    };\n\n    this.api.storage.onChanged.addListener(listener);\n\n    // Return unsubscribe function\n    return () => {\n      this.api.storage.onChanged.removeListener(listener);\n    };\n  }\n\n  /**\n   * Reset storage to defaults\n   * @returns {Promise<boolean>} Success status\n   */\n  async resetToDefaults() {\n    try {\n      await this.clear();\n      await this.api.storage.local.remove('_defaultsInitialized');\n      await this.initializeDefaults();\n      console.log('[Comet Storage] Reset to defaults');\n      return true;\n    } catch (error) {\n      console.error('[Comet Storage] Reset failed:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get all defaults\n   * @returns {object} Defaults object\n   */\n  getDefaults() {\n    return JSON.parse(JSON.stringify(this.defaults));\n  }\n\n  // ===== INTERNAL HELPER METHODS =====\n\n  /**\n   * Raw get without defaults fallback\n   */\n  async getRaw(key, namespace = 'auto') {\n    const storageArea = this.getStorageArea(namespace, 'read');\n    const result = await storageArea.get(key);\n    return result[key];\n  }\n\n  /**\n   * Raw set without validation\n   */\n  async setRaw(key, value, namespace = 'auto') {\n    const items = { [key]: value };\n    const storageArea = this.getStorageArea(namespace, 'write', items);\n\n    // Validate data size\n    this.validateDataSize(items, storageArea);\n\n    await storageArea.set(items);\n    return true;\n  }\n\n  /**\n   * Get default value by path\n   */\n  getDefaultByPath(path) {\n    return path.split('.').reduce((obj, key) => obj?.[key], this.defaults);\n  }\n\n  /**\n   * Merge storage result with defaults\n   */\n  mergeWithDefaults(storageData) {\n    const result = JSON.parse(JSON.stringify(this.defaults));\n\n    // Overlay storage data on defaults\n    for (const [key, value] of Object.entries(storageData)) {\n      if (key !== '_defaultsInitialized') {\n        this.setByPath(result, key, value);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Set value by path in object\n   */\n  setByPath(obj, path, value) {\n    const keys = path.split('.');\n    const lastKey = keys.pop();\n    const target = keys.reduce((o, key) => {\n      if (!(key in o)) o[key] = {};\n      return o[key];\n    }, obj);\n    target[lastKey] = value;\n  }\n\n  /**\n   * Determine appropriate storage area\n   */\n  getStorageArea(namespace, operation, data = null) {\n    if (namespace === 'sync') return this.api.storage.sync;\n    if (namespace === 'local') return this.api.storage.local;\n\n    // Auto mode: decide based on data size and operation\n    if (namespace === 'auto') {\n      if (operation === 'read') {\n        return this.api.storage.sync;\n      }\n\n      if (data) {\n        const dataSize = this.calculateDataSize(data);\n        return dataSize > this.syncItemQuota\n          ? this.api.storage.local\n          : this.api.storage.sync;\n      }\n    }\n\n    return this.api.storage.sync;\n  }\n\n  /**\n   * Calculate data size in bytes\n   */\n  calculateDataSize(data) {\n    try {\n      return new Blob([JSON.stringify(data)]).size;\n    } catch (error) {\n      return JSON.stringify(data).length;\n    }\n  }\n\n  /**\n   * Validate data size against storage limits\n   */\n  validateDataSize(data, storageArea) {\n    const dataSize = this.calculateDataSize(data);\n    const isSync = storageArea === this.api.storage.sync;\n\n    if (isSync) {\n      for (const [key, value] of Object.entries(data)) {\n        const itemSize = this.calculateDataSize({ [key]: value });\n        if (itemSize > this.syncItemQuota) {\n          throw new CometStorageError(\n            `Item \"${key}\" exceeds sync storage item limit (${itemSize} > ${this.syncItemQuota} bytes)`\n          );\n        }\n      }\n\n      if (dataSize > this.syncQuota) {\n        throw new CometStorageError(\n          `Data exceeds sync storage quota (${dataSize} > ${this.syncQuota} bytes)`\n        );\n      }\n    } else {\n      if (dataSize > this.localQuota) {\n        throw new CometStorageError(\n          `Data exceeds local storage quota (${dataSize} > ${this.localQuota} bytes)`\n        );\n      }\n    }\n  }\n}\n\n/**\n * Comet storage error class\n */\nclass CometStorageError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'CometStorageError';\n    this.originalError = originalError;\n  }\n}\n\n// Create and export storage instance\nexport const storage = new CometStorageManager();\n\n// Export class for advanced usage\nexport { CometStorageManager, CometStorageError };\n","/**\n * Comet Extension Messaging Utility (Cross-Browser)\n * Provides clean interface for browser messaging between extension components\n * Works with Chrome, Firefox, Edge, Opera, Brave, and other WebExtension browsers\n * @module @voilajsx/comet\n * @file src/platform/messaging.js\n */\n\n// Cross-browser API detection\nconst browserAPI = (() => {\n  if (typeof browser !== 'undefined') {\n    return browser; // Firefox, newer browsers\n  } else if (typeof chrome !== 'undefined') {\n    return chrome; // Chrome, Edge, Opera, Brave\n  } else {\n    throw new Error('No browser extension API available');\n  }\n})();\n\n/**\n * Comet Messaging Manager\n * Handles all browser extension messaging with error handling and retry logic\n */\nclass CometMessagingManager {\n  constructor() {\n    this.api = browserAPI;\n    this.messageId = 0;\n    this.pendingMessages = new Map();\n    this.messageTimeout = 30000; // 30 seconds default timeout\n    this.retryAttempts = 3;\n    this.retryDelay = 1000; // 1 second\n  }\n\n  /**\n   * Send message to background script\n   * @param {object} message - Message object\n   * @param {object} [options={}] - Options (timeout, retries)\n   * @returns {Promise<object>} Response from background\n   */\n  async sendToBackground(message, options = {}) {\n    try {\n      const messageWithId = this.createMessage(message);\n      const timeout = options.timeout || this.messageTimeout;\n      const retries = options.retries || this.retryAttempts;\n\n      return await this.retryOperation(\n        () => this.sendRuntimeMessage(messageWithId, timeout),\n        retries,\n        'background script'\n      );\n    } catch (error) {\n      console.error('[Comet Messaging] Background message failed:', error);\n      throw new CometMessagingError(\n        'Failed to communicate with background script',\n        error\n      );\n    }\n  }\n\n  /**\n   * Send message to content script in active tab\n   * @param {object} message - Message object\n   * @param {number} [tabId] - Specific tab ID (defaults to active tab)\n   * @param {object} [options={}] - Options (timeout, retries)\n   * @returns {Promise<object>} Response from content script\n   */\n  async sendToContent(message, tabId = null, options = {}) {\n    try {\n      const targetTabId = tabId || (await this.getActiveTabId());\n      const messageWithId = this.createMessage(message);\n      const timeout = options.timeout || this.messageTimeout;\n      const retries = options.retries || this.retryAttempts;\n\n      if (!targetTabId) {\n        throw new Error('No active tab found');\n      }\n\n      return await this.retryOperation(\n        () => this.sendTabMessage(targetTabId, messageWithId, timeout),\n        retries,\n        `content script (tab ${targetTabId})`\n      );\n    } catch (error) {\n      console.error('[Comet Messaging] Content script message failed:', error);\n      throw new CometMessagingError(\n        'Failed to communicate with content script',\n        error\n      );\n    }\n  }\n\n  /**\n   * Send message to specific tab\n   * @param {number} tabId - Tab ID\n   * @param {object} message - Message object\n   * @param {object} [options={}] - Options (timeout, retries)\n   * @returns {Promise<object>} Response from tab\n   */\n  async sendToTab(tabId, message, options = {}) {\n    try {\n      const messageWithId = this.createMessage(message);\n      const timeout = options.timeout || this.messageTimeout;\n      const retries = options.retries || this.retryAttempts;\n\n      return await this.retryOperation(\n        () => this.sendTabMessage(tabId, messageWithId, timeout),\n        retries,\n        `tab ${tabId}`\n      );\n    } catch (error) {\n      console.error('[Comet Messaging] Tab message failed:', error);\n      throw new CometMessagingError(\n        `Failed to communicate with tab ${tabId}`,\n        error\n      );\n    }\n  }\n\n  /**\n   * Broadcast message to all tabs with content scripts\n   * @param {object} message - Message object\n   * @param {object} [options={}] - Options (timeout, retries)\n   * @returns {Promise<array>} Array of responses from all tabs\n   */\n  async broadcast(message, options = {}) {\n    try {\n      const tabs = await this.api.tabs.query({});\n      const messageWithId = this.createMessage(message);\n      const responses = [];\n\n      for (const tab of tabs) {\n        try {\n          const response = await this.sendToTab(tab.id, messageWithId, {\n            ...options,\n            retries: 1, // Lower retries for broadcast\n          });\n          responses.push({\n            tabId: tab.id,\n            url: tab.url,\n            success: true,\n            response,\n          });\n        } catch (error) {\n          responses.push({\n            tabId: tab.id,\n            url: tab.url,\n            success: false,\n            error: error.message,\n          });\n        }\n      }\n\n      return responses;\n    } catch (error) {\n      console.error('[Comet Messaging] Broadcast failed:', error);\n      throw new CometMessagingError('Failed to broadcast message', error);\n    }\n  }\n\n  /**\n   * Listen for messages from any source\n   * @param {function} callback - Message handler (message, sender) => response\n   * @returns {function} Unsubscribe function\n   */\n  onMessage(callback) {\n    const listener = (message, sender, sendResponse) => {\n      try {\n        const result = callback(message, sender);\n\n        // Handle async responses\n        if (result instanceof Promise) {\n          result\n            .then((response) => sendResponse(response))\n            .catch((error) =>\n              sendResponse({\n                success: false,\n                error: error.message,\n              })\n            );\n          return true; // Keep message channel open\n        }\n\n        // Handle sync responses\n        if (result !== undefined) {\n          sendResponse(result);\n        }\n      } catch (error) {\n        console.error('[Comet Messaging] Message handler error:', error);\n        sendResponse({\n          success: false,\n          error: error.message,\n        });\n      }\n    };\n\n    this.api.runtime.onMessage.addListener(listener);\n\n    // Return unsubscribe function\n    return () => {\n      this.api.runtime.onMessage.removeListener(listener);\n    };\n  }\n\n  /**\n   * Listen for messages of specific type\n   * @param {string} type - Message type to listen for\n   * @param {function} callback - Message handler (data, sender) => response\n   * @returns {function} Unsubscribe function\n   */\n  onMessageType(type, callback) {\n    return this.onMessage((message, sender) => {\n      if (message.type === type) {\n        return callback(message.data, sender);\n      }\n    });\n  }\n\n  /**\n   * Get current active tab\n   * @returns {Promise<object|null>} Active tab or null\n   */\n  async getActiveTab() {\n    try {\n      const [activeTab] = await this.api.tabs.query({\n        active: true,\n        currentWindow: true,\n      });\n      return activeTab || null;\n    } catch (error) {\n      console.error('[Comet Messaging] Failed to get active tab:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get active tab ID\n   * @returns {Promise<number|null>} Active tab ID or null\n   */\n  async getActiveTabId() {\n    const tab = await this.getActiveTab();\n    return tab?.id || null;\n  }\n\n  /**\n   * Check if tab supports content scripts\n   * @param {object|string} tab - Tab object or URL string\n   * @returns {boolean} True if tab supports content scripts\n   */\n  isTabSupported(tab) {\n    const url = typeof tab === 'string' ? tab : tab?.url;\n    if (!url) return false;\n\n    const unsupportedPrefixes = [\n      'chrome://',\n      'chrome-extension://',\n      'moz-extension://',\n      'about:',\n      'file://',\n      'ftp://',\n      'data:',\n      'blob:',\n    ];\n\n    return !unsupportedPrefixes.some((prefix) => url.startsWith(prefix));\n  }\n\n  /**\n   * Create message with unique ID and timestamp\n   * @private\n   */\n  createMessage(message) {\n    return {\n      id: ++this.messageId,\n      timestamp: Date.now(),\n      ...message,\n    };\n  }\n\n  /**\n   * Send runtime message with timeout\n   * @private\n   */\n  async sendRuntimeMessage(message, timeout) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error('Message timeout'));\n      }, timeout);\n\n      this.api.runtime.sendMessage(message, (response) => {\n        clearTimeout(timeoutId);\n\n        if (this.api.runtime.lastError) {\n          reject(new Error(this.api.runtime.lastError.message));\n          return;\n        }\n\n        resolve(response || { success: false, error: 'No response' });\n      });\n    });\n  }\n\n  /**\n   * Send tab message with timeout\n   * @private\n   */\n  async sendTabMessage(tabId, message, timeout) {\n    return new Promise((resolve, reject) => {\n      const timeoutId = setTimeout(() => {\n        reject(new Error('Message timeout'));\n      }, timeout);\n\n      this.api.tabs.sendMessage(tabId, message, (response) => {\n        clearTimeout(timeoutId);\n\n        if (this.api.runtime.lastError) {\n          reject(new Error(this.api.runtime.lastError.message));\n          return;\n        }\n\n        resolve(response || { success: false, error: 'No response' });\n      });\n    });\n  }\n\n  /**\n   * Retry operation with exponential backoff\n   * @private\n   */\n  async retryOperation(operation, maxRetries, target) {\n    let lastError;\n\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error;\n\n        if (attempt === maxRetries) break;\n\n        const delay = this.retryDelay * Math.pow(2, attempt);\n        console.warn(\n          `[Comet Messaging] Retry ${\n            attempt + 1\n          }/${maxRetries} for ${target} after ${delay}ms:`,\n          error.message\n        );\n        await this.sleep(delay);\n      }\n    }\n\n    throw lastError;\n  }\n\n  /**\n   * Sleep utility\n   * @private\n   */\n  sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n\n  /**\n   * Set global message timeout\n   * @param {number} timeout - Timeout in milliseconds\n   */\n  setTimeout(timeout) {\n    this.messageTimeout = timeout;\n  }\n\n  /**\n   * Set global retry configuration\n   * @param {number} attempts - Number of retry attempts\n   * @param {number} delay - Base delay in milliseconds\n   */\n  setRetryConfig(attempts, delay) {\n    this.retryAttempts = attempts;\n    this.retryDelay = delay;\n  }\n}\n\n/**\n * Comet messaging error class\n */\nclass CometMessagingError extends Error {\n  constructor(message, originalError) {\n    super(message);\n    this.name = 'CometMessagingError';\n    this.originalError = originalError;\n  }\n}\n\n// Create and export messaging instance\nexport const messaging = new CometMessagingManager();\n\n// Export class for advanced usage\nexport { CometMessagingManager, CometMessagingError };\n"],"file":"messaging-CQ-fz_cX.js"}